package wck{		import Box2DAS.*;	import Box2DAS.Collision.*;	import Box2DAS.Collision.Shapes.*;	import Box2DAS.Common.*;	import Box2DAS.Dynamics.*;	import Box2DAS.Dynamics.Contacts.*;	import Box2DAS.Dynamics.Joints.*;	import cmodule.Box2D.*;	import wck.*;	import shapes.*;	import misc.*;	import extras.*;	import flash.utils.*;	import flash.events.*;	import flash.display.*;	import flash.text.*;	import flash.geom.*;	//	//	import com.molydeux.Hazard;	import com.molydeux.Goal;	import com.molydeux.Secret;	import com.molydeux.DoorDestroy;	import com.molydeux.PlayerModel;	import com.molydeux.BabyModel;	//	import com.utils.SoundControl;//	import com.greensock.TweenMax;	import com.greensock.easing.*;	//	import com.utils.InterfaceEvent;	import com.utils.ResizeUtil;		//			public class Avatar extends Box {				private const MAX_VELOCITY:int = 5;		public var contacts:ContactList;				public var lightMask:MovieClip;		//		public var _bg:MovieClip;		//		// public var theBaby:BabyModel;		//		public var theGFX:MovieClip;		//		public var theHilites:MovieClip;		//		private var _stage:Stage;		//		private var babyTimer:Timer =  new Timer(1000);		//		var left:Boolean;		var right:Boolean;		var jump:Boolean;							public override function create():void {			reportBeginContact = true;			reportEndContact = true;			fixedRotation = true;			super.create();			listenWhileVisible(world, StepEvent.STEP, parseInput, false, 10);			listenWhileVisible(this, ContactEvent.BEGIN_CONTACT, handleContact);			contacts = new ContactList();			contacts.listenTo(this);			//			_stage = ResizeUtil.getInstance().stage;			_stage.addEventListener(InterfaceEvent.UPDATEAVATAR, updateMask, false, 0, true);			_stage.addEventListener(InterfaceEvent.SHAKEBABY, shakeBaby, false, 0, true);			_stage.addEventListener(InterfaceEvent.ZAPAVATAR, doZap, false, 0, true);			//			//// timer			babyTimer.addEventListener(TimerEvent.TIMER,doBabyResize);			//			initMask();			/// 			initGFX();			// 			// addBaby();			// theBaby = new BabyModel();		}								private function initMask():void{			lightMask = new mask_circle_mc();			lightMask.cacheAsBitmap = true;			// world.cacheAsBitmap = true;						addChild(lightMask);						updateMask(null);			// lightMask.y = -20;			// world.mask=lightMask;			// _bg = world.bg;			// _stage.addChildAt(_bg, 0);		}				private function initGFX():void{			theGFX = new avatar_gfx();			addChild(theGFX);						theHilites = new hilites_gfx();			addChild(theHilites);								}		/*		private function addBaby():void{			theBaby = new BabyModel();			addChild(theBaby);			// theBaby.x = theBaby.width;			// theBaby.y -= theBaby.height;		}			*/					////// DOES HIT STATES WITH SPECIAL OBSTACLES		public function handleContact(e:ContactEvent):void {			/*			var p:Pellet = e.other.m_userData as Pellet;			if(p) {				Util.addChildAtPosOf(world, new FX1(), p);  				p.remove();			}			*/			var h:Hazard = e.other.m_userData as Hazard;			if(h) {								if(h.hazardInactive==true){					// doOpen(null);					h.doDestroy();								} else {					doZap(null);				}			}			var g:Goal = e.other.m_userData as Goal;			if(g) {					doGoal(null);					try{											} catch (e:Error){						trace("Can't do avatar");					}				}						var s:Secret = e.other.m_userData as Secret;			if(s && s.secretFound == false) {				doSecret(null);				s.secretFound = true;			}			var d:DoorDestroy = e.other.m_userData as DoorDestroy;			if(d) {				trace("Opened" + d.doorOpened + " " + BabyModel.babyHealth);				if(d.doorOpened==true){				// doOpen(null);				d.doDestroy();								}				/// this is where we kill the door			}			doAvatarStandStill();			dispatchEvent(new InterfaceEvent("updateHUD"));		}				///////// end hit states /////						///////// INPUT FUNCTIONS /////////////////////		public function parseInput(e:Event):void {			var manifold:b2WorldManifold = null;			var dot:Number = -1;						// Search for the most ground/floor-like contact.			if(!contacts.isEmpty()) {				contacts.forEach(function(keys:Array, c:ContactEvent) {					var wm:b2WorldManifold = c.getWorldManifold();					if(wm.normal) { 												// Dot producting the contact normal with gravity indicates how floor-like the						// contact is. If the dot product = 1, it is a flat foor. If it is -1, it is						// a ceiling. If it's 0.5, it's a sloped floor. Save the contact manifold						// that is the most floor like.						var d:Number = wm.normal.dot(gravity);						if(!manifold || d > dot) {							manifold = wm;							dot = d;						}					}				});				contacts.clean();			}			left = Input.kd('A', 'LEFT');			right = Input.kd('D', 'RIGHT');			jump = Input.kp('W', 'UP');			var v:V2;						// Here we could add a dot product threshold for disallowing the player from jumping			// off of walls, ceilings, etc. For example:			// if(jump && manifold && dot > 0) {			if(jump && manifold) {				PlayerModel.standPos = "jump";				v = manifold.normal.clone().multiplyN(PlayerModel.playerJump);				b2body.ApplyImpulse(v, b2body.GetWorldCenter());				theGFX.gotoAndPlay("jump");			}			else if(left) {				PlayerModel.standPos = "left";				if (b2body.GetLinearVelocity().x < -MAX_VELOCITY) return;				b2body.ApplyImpulse(new V2(-1*PlayerModel.playerSpeed, 0), b2body.GetWorldCenter());				if(PlayerModel.isWalking == false){					PlayerModel.isWalking = true;										theGFX.gotoAndPlay("left");					// theBaby.gotoAndPlay("leftlargeshake");				}							}			else if(right) {				PlayerModel.standPos = "right";				if (b2body.GetLinearVelocity().x > MAX_VELOCITY) return;				b2body.ApplyImpulse(new V2(PlayerModel.playerSpeed, 0), b2body.GetWorldCenter());				if(PlayerModel.isWalking == false){					PlayerModel.isWalking = true;										theGFX.gotoAndPlay("right");					// theBaby.gotoAndPlay("rightlargeshake");				}									} else {								doAvatarStandStill();			}		}		private function doAvatarStandStill():void{						PlayerModel.isWalking = false;			if(PlayerModel.standPos == "left"){				theGFX.gotoAndStop("standleft");				// theBaby.gotoAndStop("leftlargestand");			}else if(PlayerModel.standPos == "right"){				theGFX.gotoAndStop("standright");				// theBaby.gotoAndStop("rightlargestand");			}		}				//// end input functions //////////				//// GOAL FUNCTIONS //////		private function doGoal(e:Event):void{						trace("GOAL REACHED");			// theHilites.gotoAndPlay("zapped");			doAvatarStandStill();			dispatchEvent(new InterfaceEvent("reachedGoal"));		}		/// end goal functions				///// SECRET FUNCTIONS //////////		private function doSecret(e:Event):void{			trace("SECRET");			doAvatarStandStill();			dispatchEvent(new InterfaceEvent("foundSecret"));			dispatchEvent(new InterfaceEvent("updateHUD"));		}		// end zap functions				///// ZAP FUNCTIONS //////////		private function doZap(e:Event):void{			trace("ZZZAAAPPPPP");			dispatchEvent(new InterfaceEvent("doScream"));			theHilites.gotoAndPlay("zapped");			if(PlayerModel.playerHealth >=1){			PlayerModel.playerHealth--;						} else {				trace("YOU LOSE");				doAvatarStandStill();			}			dispatchEvent(new InterfaceEvent("updateHUD"));		}		// end zap functions				//// SHAKE BABY FUNCTIONS //////				// do sound		private function shakeBaby(e:Event):void{			babyTimer.stop();			babyTimer.reset();			babyTimer.start();			dispatchEvent(new InterfaceEvent("shakeBabySound"));			/// check baby profile			if(BabyModel.babyHealth >=0){ 				BabyModel.numShakes +=1;				BabyModel.lightSize +=.25;				BabyModel.babyHealth --;				/// do baby size				theGFX.baby.gotoAndPlay("shake");				// TweenMax.to(theGFX.baby, .25,{scaleX:BabyModel.babySize,scaleY:BabyModel.babySize, ease:Sine.easeIn});			    /// do mask			    updateMask(null);				dispatchEvent(new InterfaceEvent("updateHUD"));											} 			if(BabyModel.babyHealth <=0){				trace("YOU HAVE KILLED YOUR BABY");				doAvatarStandStill();				dispatchEvent(new InterfaceEvent("youLose"));				dispatchEvent(new InterfaceEvent("updateHUD"));			}		}		private function doBabyResize(e:Event):void{			/// trace("TICK");						if(BabyModel.babyHealth <=5){				dispatchEvent(new Event("shrinkBaby"));				BabyModel.babySize -=.1;				BabyModel.lightSize -=.25;				BabyModel.babyHealth ++;				/// do baby size				// TweenMax.to(theGFX.baby, .75,{scaleX:BabyModel.babySize,scaleY:BabyModel.babySize, ease:Sine.easeIn});			    /// do mask			    TweenMax.to(lightMask, .05,{scaleX:BabyModel.lightSize,scaleY:BabyModel.lightSize, ease:Sine.easeIn});							} else {								babyTimer.stop();			}			dispatchEvent(new InterfaceEvent("updateHUD"));		}				/////////////// MASK FUNCTIONS				public function updateMask(e:Event):void{			lightMask.y = -40;			// update position			if(PlayerModel.standPos == "right"){				lightMask.x = 40;			} 			if (PlayerModel.standPos == "left"){				lightMask.x = -40;			}			if (PlayerModel.standPos == "jump"){				lightMask.x = 0;			}			//  - lightMask.width/2;			// lightMask.y = this.y; //  - lightMask.height/2;			/// check size against baby status			TweenMax.to(lightMask, .05,{scaleX:BabyModel.lightSize,scaleY:BabyModel.lightSize, ease:Sine.easeIn});			/*			if (_bg != null) {				_bg.x = world.x;				_bg.y = world.y;			}			*/					}						//// end class			}			/// end  pakcage}